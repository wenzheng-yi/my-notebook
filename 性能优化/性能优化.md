#### 如何让浏览器更快地加载网络资源？

可以减少响应内容大小，比如使用gzip算法压缩响应体内容和HTTP/2的压缩头部功能；另一种更通用也更为重要的技术就是**使用缓存**。

Web 缓存按存储位置来区分，包括数据库缓存、服务端缓存、CDN 缓存和**浏览器缓存**。

浏览器缓存的实现方式主要有两种：HTTP 和 ServiceWorker 。

**HTTP 缓存**
使用缓存最大的问题往往不在于将资源缓存在什么位置或者如何读写资源，而在于如何保证缓存与实际资源一致的同时，提高缓存的命中率。也就是说尽可能地让浏览器从缓存中获取资源，但同时又要保证被使用的缓存与服务端最新的资源保持一致。

为了达到这个目的，需要制定合适的缓存过期策略（简称“缓存策略”），HTTP 支持的缓存策略有两种：强制缓存和协商缓存。

强制缓存就是在缓存有效期内直接使用浏览器缓存；协商缓存则需要先询问服务端资源是否发生改变，如果未改变再使用浏览器缓存。

**ServiceWorker**
ServiceWorker 是浏览器在后台独立于网页运行的脚本，也可以这样理解，它是浏览器和服务端之间的代理服务器。ServiceWorker 非常强大，可以实现包括推送通知和后台同步等功能，更多功能还在进一步扩展，但其最主要的功能是实现离线缓存，主要实现原理是拦截浏览器请求并返回缓存的资源文件。



#### 性能优化该怎么优化？

**性能指标**

性能是指程序的运行速度，而前端性能是指页面的响应速度，性能指标是以时间为单位来测量的。

衡量前端性能的指标

- 是否可以通过浏览器采集上报
- 是否由权威组织或大型公司提出
- 是否严重影响用户体验



首屏绘制（First Paint, FP）

首屏绘制由W3C标准Paint Timing中提出，指的是从开始加载到浏览器首次绘制像素到屏幕上的时间，也就是页面在屏幕上首次发生视觉变化的时间，俗称“白屏时间”

```javascript
采集：performance.getEntriesByType('paint')[0]
```



首屏内容绘制（First Contentful Paint，FCP）

首屏内容绘制由 W3C 标准 Paint Timing 中提出。浏览器首次绘制来自 DOM 的内容时间，这个内容可以是文字、图片（也包括背景图片）、非空白的 canvas 和 svg。

```
采集：performance.getEntriesByType('paint')[1]
```

FCP 有时候会和 FP 时间相同，也可能晚于 FP。这也很好理解，FP 只需要满足“开始绘制”这一个条件就可以了，而 FCP 还要满足第二个条件，那就是“绘制的像素有内容”。



可交互时间（Time to Interactive，TTI）
可交互时间由 Web 孵化器社区组（WICG）提出，是指网页在视觉上都已渲染出了，浏览器可以响应用户的操作了。

总阻塞时间（Total Blocking Time，TBT）
总阻塞时间由 W3C 标准 Long Tasks API 1 提出，是指阻塞用户响应（比如键盘输入、鼠标点击）的所有时间。指标值是将 FCP 之后一直到 TTI 这段时间内的阻塞部分时间总和，阻塞部分是指长任务执行时间减去 50 毫秒。

最大内容绘制（Largest Contentful Paint，LCP)
最大内容绘画指的是视口内可见的最大图像或文本块的绘制时间。



**优化思路**

前端性能优化一般可以从2个方向入手：**加载性能优化**和**渲染性能优化**

大体上遵循两个思路：**做减法**和**做除法**。做减法是直接减少耗时操作或资源体积，做除法是在耗时操作和资源体积无法减少的情况下，对其进行拆分处理或者对不可拆分的内容进行顺序调换。

**加载性能的优化**手段中，**做减法**的有：

- **采用 gzip 压缩**，典型的减少资源的传输体积；
- **使用缓存**，强制缓存可以减少浏览器请求次数，而协商缓存可以减少传输体积；
- **使用雪碧图**，减少浏览器请求次数。

**做除法**的有：

- **HTTP2 多路复用**，把多个请求拆分成二进制帧，并发传输；
- **懒加载**，将 Web 应用拆分成不同的模块或文件，按需加载；
- **把 script 标签放到 body 底部**，通过调整顺序来控制渲染时间。

在**渲染性能优化**的手段中，**做减法**的有：

- **避免重排与重绘**，减少渲染引擎的绘制；
- **防抖操作**，减少函数调用或请求次数；
- **减少 DOM 操作**，减少渲染引擎和脚本引擎的切换，同时也减少渲染引擎绘制。

**做除法**的有：

- **骨架屏**，将页面内容进行拆分，调整不同部分的显示顺序；
- **使用 Web Worker**，将一些长任务拆分出来，放到 Web Worker 中执行；
- **React Fiber**，将同步视图的任务进行拆分，可调换顺序，可暂停。

前端性能优化的方式还有很多，我们学习的重点不在于将这些优化方式一一记住，而是掌握优化的思路，在不同的方向上，对不同步骤优先考虑做减法，然后再考虑做除法



知乎分享：前端性能优化24条建议

https://juejin.cn/post/6892994632968306702

https://zhuanlan.zhihu.com/p/121056616



拉钩前端讲座：

web性能优化

背景知识：B/S架构

背景知识：请求响应基本流程

核心思路：网络通信更快速地加载，获取信息后更高效地执行

面试官你想听哪个？

1、加载层面：

- CDN  Content Delivery Network

  在数据放到不同的CDN，那它会请求近的

- 缓存   MDN:Last Modified

  - 强缓存
  - 协商缓存

- HTTP2  HTTP1.1和HTTP2.0的区别

  - 多路复用
  - 压缩头

2、执行层面

- 客户端渲染方法 Client Side Render（CSR）
  - 白屏时间更长，用户体验不好
  - HTML中无内容，SEO不友好
- 服务端渲染方法 Server Side Render（SSR）
- 静态站点生成方法 Static Site Generators （SSG）
  - 专门的SSG方案 
    - GridSome 针对于Vue
    - Gatsby 针对于React
  - 副业实现SSG
    - Next.js
    - Nuxt.js



阮一峰老师的博客：如何面试一个程序员。

如果你是面试官

- 为什么要招人？
  - 某些具体的工作需要更多的劳动力
- 什么样的人能胜任？
  - 掌握特定技能，且程度符合预期
- 如何判定候选人是否达标？
  - 基本素质（技术能力、语言能力）、能力储备、培养潜力



知已知彼的面试思维

- 换位思考+同理心
- 明确主题，适当反问，带节奏
- 具体场景，经验总结+思考
- 举一反三、适当扩散
- 掌握主动权、掌握主动权、掌握主动权

注意：不要生搬硬套
